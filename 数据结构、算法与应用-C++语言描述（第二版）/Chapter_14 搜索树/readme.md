# 搜索树

## 二叉搜索树

### 定义

**二叉搜索树（binary search tree）**：是一颗二叉树，可能为空；一颗非空的二叉搜索树满足以下特征：
1. 每一个元素都有一个关键字，并且任意两个元素的关键字都不同；因此，所有的关键字都是唯一的；
1. 在根节点的左子树中，元素的关键字（如果有的话）都小于根节点的关键字；
1. 在根结点的右子树中，元素的关键字（如果有的话）都大于根结点的关键字；
1. 根结点的左、右子树也都是二叉搜索树。

**有重复值的二叉搜索树（binary search tree with duplicates）**：用小于等于和大于等于代替二叉搜索树中的小于和大于即可。

**索引二叉搜索树（indexed binary search tree）**：源于普通的二叉搜索树，只是在每个节点中添加一个 leftSize 域，这个域的值是该节点左子树的元素个数。

### 抽象数据类型

```
抽象数据类型 bsTree
{
    实例：
        二叉树，每一个节点都有一个数对，其中一个成员是关键字，另一个成员是数值；所有关键字都不相同；
        任何一个节点的左子树的关键字都小于该节点的关键字；右子树的关键字大于该节点的关键字

    操作：
        find(k):                // 返回关键字为 k 的数对
        insert(p):              // 插入数对 p
        erase(k):               // 删除关键字为 k 的数对
        ascend():               // 按关键字升序输出所有数对
}

抽象数据类型 IndexedBSTree
{
    实例：
        与 bsTree 的实例相同，只是每一个节点还有一个 leftSize 域

    操作：
        find(k):                // 返回关键字为 k 的数对
        get(index):             // 返回第 index 个数对
        insert(p):              // 插入数对 p
        erase(k):               // 删除关键字为 k 的数对
        ascend():               // 按关键字升序输出所有数对
}
```

### 二叉搜索树的操作和实现

1. **搜索**：假设要查找关键字为 theKey 的元素。先从根开始查找。如果根为空，那么搜索树不包含任何元素，即查找失败。如果不空，则将 theKey 与根的关键字比较。如果 theKey 小，那么就只要查找左子树；如果 theKey 大，则正好相反，只需查找右子树；如果 theKey 等于根的关键字，则查找成功。在子树的查找与此类似。该过程的时间复杂性为 O(h)，h 为树的高度。
1. **插入**：假设要在二叉搜索树中插入一个新元素 thePair，首先要通过查找来确定，在树中是否存在某个元素，其关键字与 thePair.first 相同，如果搜索成功，那么就用 thePair.second 替代该元素的值；如果搜索不成功，那么就将新元素作为搜索中断节点的孩子插入二叉搜索树中。
1. **删除**：假设要删除的节点是 p，需要考虑以下三种情况：
    1. p 是叶节点：处理方法是释放该叶节点空间，若是根结点，则令根为 NULL。
    1. p 只有一颗非空子树：如果 p 没有父节点（即 p 是根结点），则 p 的唯一子树的根结点成为新的搜索树的根结点。如果 p 有父节点 pp，则修改 pp 的指针域，使它指向 p 的唯一孩子，然后释放节点 p。
    1. p 有两棵非空子树：先将该节点的元素替换为它的左子树的最大元素或右子树的最小元素，然后把替换元素的节点删除。（要在一个节点的左子树中查找关键字最大的元素，先移动到左子树的根，然后沿着右孩子指针移动，直到右孩子指针为 NULL 的节点为止。类似的，要在一个节点的右子树中查找关键字最大的元素，先移动到右子树的根，然后沿着左孩子指针移动，直到左孩子指针为 NULL 的节点为止。）