# 图

## 基本概念

**图（graph）**：是一个用线或边连接在一起的定点或节点的集合。严格地说，图是有限集 V 和 E 的有序对，即 $G=(V,E)$，其中 V 的元素称为顶点，E 的元素称为边。每一条边连接两个不同的顶点，而且用元祖 $(i,j)$ 来表示，其中 $i$ 和 $j$ 是边所连接的两个顶点。

带方向的边叫 **有向边（directed edge）**，不带方向的边叫 **无向边（undirected edge）**。

当且仅当 $(i,j)$ 是图的边，称顶点 $i$ 和 $j$ 是 **邻接的（adjacent）**。边 $(i,j)$ **关联（incident）** 于顶点 $i$ 和 $j$。

有向边 $(i,j)$ 是 **关联至（incident to）** 顶点 $j$ 而 **关联与（incident from）** 顶点 $i$。顶点 $i$ **邻接至（adjacent to）** 顶点 $j$，顶点 $j$ **邻接于（adjacent from）** 顶点 $i$。

如果图的所有边都是无向边，那么该图叫做 **无向图（undirected graph）**。如果图的所有边都是有向边，那么该图叫做 **有向图（directed graph 或 digraph）**。

一个图不可能包含 **自连边（self-edge)**，即 $(i,j)$ 形式的边。自连边也叫做 **环（loop）**。

为每条边赋予一个表示成本的值，称之为 **权**。这时的图称为 **加权有向图（weighted digraph）** 和 **加权无向图（weighted undirected graph）**。一个 **网络（network）** 经常指一个加权有向图或加权无向图。

一条路径，如果除第一个和最后一个顶点外，其余所有顶点均不同，那么该路径称为一条 **简单路径（simple path）**。一条路径的长度是该路径的所有边长度之和。

设 $G=(V,E)$ 是一个无向图。$G$ 是 **连通的（connected）**，当且仅当 $G$ 的每一对顶点之间都有一条路径。

如果 $H$ 的顶点和边的集合分别是 $G$ 的顶点和边的集合的子集，那么称图 $H$ 是图 $G$ 的 **子图（subgraph）**。一条始点和终点相同的简单路径称为 **环路（cycle）**。没有环路的连通无向图是一棵 **树（tree）**。一个 $G$ 的子图，如果包含 $G$ 的所有顶点，且是一棵树，则称为 $G$ 的 **生成树（spanning tree）**。

一个图，顶点被分为两个子集 $A$ 和 $B$，每条边都有一个顶点在 $A$ 中，一个顶点在 $B$ 中，具有这种特征的图称为 **二分图（bipartite graph）**。

## 特性

在一个无向图中，与一个顶点 $i$ 相关联的边数称为该顶点的 **度（degree）** $d_i$。

**特性一**：设 $G=(V,E)$ 是一个无向图。令 $n={\mid}V{\mid}, e={\mid}E{\mid}$，则：
1. ${\sum_{i=1}^{n}}{d_i}=2e$
1. $0{\leq}e{\leq}n(n-1)/2$

一个具有 n 个顶点和 n(n-1)/2 条边的无向图是一个 **完全图（complete graph）**。

在一个有向图中，顶点 $i$ 的 **入度（in-degree）** $d_i^{in}$ 是指关联至该顶点的边数，顶点 $i$ 的 **出度（out-degree）** $d_i^{out}$ 是指关联与该顶点的边数。

**特性二**：设 $G=(V,E)$ 是一个有向图。令 $n={\mid}V{\mid}, e={\mid}E{\mid}$，则：
1. $0{\leq}e{\leq}n(n-1)$
1. ${\sum_{i=1}^{n}}{d_i^{in}} = {\sum_{i=1}^{n}}{d_i^{out}} = e$

## 抽象数据类型
```
抽象数据类型 graph
{
    实例：
        顶点集合 V 和边集合 E

    操作：
        numberOfVertices():             // 返回图的顶点数
        numberOfEdge(i,j):              // 返回图的边数
        existsEdge(i,j):                // 如果边 (i,j) 存在，返回 true，否则返回 false
        insertEdge(i,j):                // 插入边 (i,j)
        eraseEdge(i,j):                 // 删除边 (i,j)
        degree(i):                      // 返回顶点 i 的度，只用于无向图
        inDegree(i):                    // 返回顶点 i 的入度
        outDegree(i):                   // 返回顶点 i 的出度
}
```

## 描述

**无权图描述**：
1. 邻接矩阵：一个 n 顶点的图 $G=(V,E)$ 的邻接矩阵是一个 $n*n$ 的矩阵（假设是 A），其中每个元素是 0 或 1。如果是无向图，则当 $(i,j){\in}E{\;}or{\;}(j,i){\in}E$ 时，$A(i,j)=1$，否则 $A(i,j)=0$。如果是有向图，则当 $(i,j){\in}E$ 时，$A(i,j)=1$，否则 $A(i,j)=0$。
1. 邻接链表：一个顶点 $i$ 的 **邻接表（adjacency list）** 是一个线性表，它包含所有邻接与顶点 $i$ 的顶点。在一个图的邻接表描述中，图的每一个顶点都有一个邻接表。当邻接表用链表表示时，就是邻接链表。
1. 邻接数组：在邻接数组中，每一个邻接表用一个数组线性表而非链表来描述。

**有权图描述**：
1. 成本邻接矩阵：在这种描述中，需要给不存在的边指定一个值，一般是一个很大的值。
1. 邻接链表：如果链表的元素有两个域 vertex 和 weight，就可以从相应的无向图的邻接链表得到加权图的邻接链表。
1. 邻接数组：每一个元素用数对 (vertex,weight) 表示，就可以从想用的无权图的数组邻接矩阵得到加权图的数组邻接矩阵。

## 图的遍历

有两种常用的方法；

**广度优先搜索（breadth first search, BFS）**：

类似于二叉树的层序遍历，它的基本思想就是：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1，w2，…，wi，然后再依次访问w1，w2，…，wi的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们所有未被访问过的邻接顶点……依次类推，直到图中所有顶点都被访问过为止。

广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记录正在访问的顶点的下一层顶点。

**深度优先搜索（depth first search, DFS）**：

深度优先搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图。它的基本思想就是：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，……重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。

**总结**：

不过，要获得效率更高的图的算法，深度优先搜索方法使用得更多。

