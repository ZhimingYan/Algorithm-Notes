# 1. 优先级队列

**定义**：优先级队列（priority queue）是 0 个或多个元素的集合，每个元素都有一个优先权或值，对优先级队列执行的操作有：
1. 查找一个元素
1. 插入一个元素
1. 删除一个元素
与这些操作分别对应的函数是 top、push 和 pop。

在最小优先级队列（min priority queue）中，查找和删除的元素都是优先级最小的元素；在最大优先级队列（max priority queue）中，查找和删除的元素都是优先级最小的元素。优先级队列的元素可以有相同的优先级，对这样的元素，查找和删除可以按任意顺序处理。

**抽象数据类型**：
```
抽象数据类型 maxPriorityQueue
{
    实例：
        有限个元素的集合，每一个元素都有优先级

    操作：
        empty():        // 返回值为 true，当且仅当队列为空
        size():         // 返回队列的元素个数
        top():          // 返回优先级最大的元素
        pop():          // 删除优先级最大的元素
        push(x):        // 插入元素 x
}
```

## 1.1. 堆

一颗大根树（小根树）是这样一棵树，其中每个节点的值都大于（小于）或等于其子节点（如果有的话）的值。

**定义**：一个大根堆（小根堆）既是大根树（小根树），也是完全二叉树。

**操作**：
- 大根堆插入：把新元素插入新节点，然后沿着从新节点到根结点的路径，执行一趟起泡操作，将新元素与其父节点比较交换，直到后者大于或等于前者为止。
- 大根堆删除：将最后一个元素与根元素交换，删除最后一个元素，然后调整整棵树使其成为大根堆。

**时间复杂度**：
实现上述插入和删除策略的时间复杂性均为 O(height)=O(logn)。

## 1.2. 左高树

对于一颗二叉树，它有一类特殊的节点叫做外部节点（external node），它代替树中的空子树。其余节点叫做内部节点（internal node）。增加了外部节点的二叉树被称为扩充二叉树（extended binary tree）。

令 $s(x)$ 是从节点 $x$ 到其子树的外部节点的所有路径中最短的一条。根据 $s(x)$ 的定义，若 $x$ 是外部节点，则 $s$ 的值为 0；若 $x$ 为内部节点，则 $s$ 的值为：
$$min{\lbrace}{s(L),s(R)}{\rbrace}+1$$
其中 $L$ 和 $R$ 分别为 $x$ 的左右孩子。

**定义**：一颗二叉树称为**高度优先左高树（height-biased leftist tree，HBLT）**，当且仅当其任何一个内部节点的左孩子的 $s$ 值都大于或等于右孩子的 $s$ 值。

**特性**：
1. 令 $x$ 为 $HBLT$ 的一个内部节点，则：
    - 以 $x$ 为根的子树的节点数目至少为 $2^{s(x)}-1$；
    - 若以 $x$ 为根的子树有 $m$ 个节点，那么 $s(x)$ 最多为 $log_2(m+1)$；
    - 从 $x$ 到一个外部节点的最右路径（即从 $x$ 开始沿右孩子移动的路径）的长度为 $s(x)$。
1. 若一颗 $HBLT$ 同时还是大根树，则称为最大 $HBLT(max HBLT)$。若一颗 $HBLT$ 同时还是小根树，则称为最小 $HBLT(min HBLT)$。

**定义**：一颗二叉树称为**重量优先左高树（weight-biased leftist tree，WBLT）**，当且仅当其任何一个内部节点的左孩子的 $w$ 值都大于或等于右孩子的 $w$ 值。若一颗 $WBLT$ 同时还是大根树，则称为最大 $WBLT(max WBLT)$。若一颗 $WBLT$ 同时还是小根树，则称为最小 $WBLT(min WBLT)$。

**操作**：
- **最大 $HBLT$ 的插入**：最大 $HBLT$ 的插入操作可利用最大 $HBLT$ 的合并操作来实现。要插入一个元素，可以先建立一颗新的只包含这个元素的 $HBLT$，然后将这颗新的 $HBLT$ 与原来的 $HBLT$ 合并即可。
- **最大 $HBLT$ 的删除**：最大元素在根中，若根被删除，则分别以左右孩子为根的子树是两颗最大 $HBLT$。将这两颗最大 $HBLT$ 合并，便是删除后的结果。
- **两颗最大 $HBLT$ 的合并**：具有 $n$ 个元素的最大 $HBLT$，其最右路径的长度为 $O(logn)$。合并操作操作仅需遍历欲合并的 $HBLT$ 的最右路径，即仅需移动右孩子。合并策略最好用递归来实现。令 $A,B$ 是需要合并的两棵最大 $HBLT$，假设两者均不为空，为实现合并，首先需要检查两个根元素，较大者是合并后 $HBLT$ 的根。假设 $A$ 具有较大的根，且其左子树是 $L$,$C$ 是由 $A$ 的右子树与 $B$ 合并而成的 $HBLT$。所以 $A,B$ 合并的结果是以 $A$ 的根为根，$L,C$ 为左右子树的最大 $HBLT$。如果 $L$ 的 $s$ 值小于 $C$ 的 $s$ 值，则 $C$ 是右子树，$L$ 是左子树。
- **初始化**：通过将 $n$ 个元素插入到最初为空的最大 $HBLT$ 中来进行初始化，所需时间是 $O(logn)$。为得到具有线性时间的初始化算法，首先创建 $n$ 个最大 $HBLT$，每个树中仅包含 $n$ 个元素中的某一个，这 $n$ 棵树排成一个 $FIFO$ 队列，然后从队列中依次删除两个 $HBLT$，将其合并，然后再加入队列末尾，直到最后只有一棵 $HBLT$。

**时间复杂度**：
使用 $WBLT$ 或 $HBLT$，可以执行优先级队列的查找、插入、删除操作，其时间复杂性与堆相同。和堆一样， $WBLT$ 或 $HBLT$ 可以在线性时间内完成初始化。用 $WBLT$ 或 $HBLT$ 表示的两个优先级队列可在对数时间内合并为一个，而用堆表示的优先级队列做不到这一点。