# 1. 跳表和散列

有序数组、有序链表、跳表、哈希表的性能如下：

**最坏情况**：

| 方法 | 查找 | 插入 | 删除 |
|:-----:|:-----:|:-----:|:-----:|
| 有序数组 | O(logn) | O(n) | O(n) |
| 有序链表 | O(n) | O(n) | O(n) |
| 跳表 | O(n) | O(n) | O(n) |
| 哈希表 | O(n) | O(n) | O(n) |

**平均情况**：

| 方法 | 查找 | 插入 | 删除 |
|:-----:|:-----:|:-----:|:-----:|
| 有序数组 | O(logn) | O(n) | O(n) |
| 有序链表 | O(n) | O(n) | O(n) |
| 跳表 | O(logn) | O(logn) | O(logn) |
| 哈希表 | O(1) | O(1) | O(1) |

## 1.1. 字典

字典（dictionary）是由一些形如（k,v）的数对所组成的集合，其中 k 是关键字，v 是与关键字 k 对应的值，任意两个数对，其关键字都不等。

多重字典（dictionary with duplicate）与上述字典类似，只是两个或更多的数对可以具有相同的关键字。

```
抽象数据类型 Dictionary
{
    实例：
        关键字各不相同的一组数对

    操作：
        empty():            // 返回 true，当且仅当字典为空
        size():             // 返回字典的数对个数
        find(k):            // 返回关键字为 k 的数对
        insert(p):          // 插入数对 p
        erase(k):           // 删除关键字为 k 的数对
}
```

## 1.2. 跳表

略

## 1.3. 散列表

散列（hashing）是字典的一种表示方法。它用一个散列函数（也称哈希函数）把字典的数对映射到一个散列表的具体位置。如果数对p 的关键字是k，散列函数为 f，那么在理想情况下，p在散列表中的位置为 f(k)。

散列表的没一个位置叫一个**桶（bucket）**；对关键字为 k 的数对，f(k) 是**起始桶（home bucket）**；桶的数量等于散列表的长度或大小。

当两个不同的关键字所对应的起始桶相同时，就是**冲突（collision）**发生了。当一个桶可以存储多个数对时，发生碰撞也没什么问题。如果存储桶没有空间存储一个新数对，就是**溢出（overflow）**发生了。最常用的溢出处理方法是**线性探查法**，其他方法还有**平法探查法**，**双重散列法**。

**线性探查法**：当溢出发生时，查找下一个可用的桶。在查找下一个可用桶时，散列表被视为环形表。
- 查找：假设要查找的关键字为 k 的数对，首先搜索起始桶 f(k)，然后把散列表当作环表继续搜索下一个桶，直到以下情况之一发生为止：1)存有关键字 k 的桶已找到；2)到达一个空桶；3)又回到起始桶 f(k)。后两种情况说明关键字 k 不存在。
- 插入：当要插入关键字为 k 的数对时，如果起始桶 f(k) 为空，则插入在起始桶中；否则，查找下一个可用的桶，如果不存在空桶，则插入失败，必需重新组织这个散列表。
- 删除：删除需要移动若干个数对。从删除位置的下一个桶开始，逐个检查每个桶，以确定要移动的元素，直到到达一个空桶或回到删除位置为止。在做删除移动时，一定不能把一个数对移到它的起始桶之前，否则，对这个数对的查找就可能失败。

**链式散列**：如果散列表的每一个桶可以容纳无限多个记录，那么溢出就不存在了。实现这个目标的一个方法是给散列表的每一个位置配置一个线性表。这时，每一个数对都可以存储在它的起始桶线性表中。一般用有序链表来表示线性表。