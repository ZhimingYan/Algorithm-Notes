# 竞赛树

## 赢者树

**定义**：有 n 个选手的一颗 **赢者树** 是一颗完全二叉树，它有 n 个外部节点和 n-1 个内部节点，每个内部节点记录的是在该节点比赛的赢者。

为了确定一场比赛的赢者树，假设每个选手都有一个分数，而且有一个规则用来比较两个选手的分数以确定赢者。在 **最小赢者树（min winner tree）** 中，分数小的选手获胜；在 **最大赢者树（max winner tree）** 中，分数大的选手获胜。在分数相等，即平局的时候，左孩子表示的选手获胜。

**操作**：赢者树有三种操作：
1. 初始化一颗赢者树；
1. 返回赢者；
1. 重新组织从选手 i 到根的路径上的比赛。

**内部排序法**：要求待排序的元素全部放入计算机内存；

**外部排序法**：是指能够处理极大量数据的排序算法。通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。尔后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。一般包含两个步骤：
1. 生成一些初始归并段（run），每一个初始归并段都是有序集；
1. 将这些初始归并段合并为一个归并段。

**归并排序**：可以用一颗最小赢者树（或者最大赢者树），用时 O(nlogn) 对 n 个元素排序。首先，用 n 个元素代表 n 名选手对赢者树进行初始化。关键字决定每场比赛的结果，总冠军是关键字最小的元素。将该元素的关键字输出到输出序列中，然后初始序列中对应的值改为最大值（如 ∞），使它在之后的比赛中赢不了其他任何选手。然后重构赢者树，以反映出该元素的关键字的变化。这时的总冠军是按序排在第二的元素，将其输出到输出序列中，再将该值改为 ∞，再一次重构赢者树，依次类推，可以完成 n 个元素的排序。整个排序过程用时为 O(nlogn)。

## 输者树

**定义**：**败者树** 是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。