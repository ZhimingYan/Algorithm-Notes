# 平衡搜索树

最坏情况下的高度为 O(logn) 的树称为**平衡树（balanced tree）**

## AVL 树

**定义**：一颗空的二叉树是 $AVL$ 树；如果 $T$ 是一颗非空的二叉树，$T_L$ 和 $T_R$ 分别是其左子树和右子树，那么当 $T$ 满足以下条件时，$T$ 是一颗 $AVL$ 树：
1. $T_L$ 和 $T_R$ 是 $AVL$ 树；
1. ${\mid}h_L-h_R{\mid}{\leq}1$，其中 $h_L$ 和 $h_R$ 分别是 $T_L$ 和 $T_R$ 的高。

一棵 **AVL 搜索树** 既是二叉搜索树，也是 AVL 树。

一棵 **索引 AVL 搜索树** 既是索引二叉树，也是 AVL 树。

**特征**：
1. 一棵 n 个元素的 AVL 树，其高度是 $O(logn)$。
1. 对于每一个 $n(n{\geq}0)$，都存在一棵 AVL 树。
1. 对一棵 n 元素的 AVL 搜索树，在 O(高度)=$O(logn)$ 的时间内可以实现查找。
1. 将一个新元素插入一棵 n 元素的 AVL 搜索树中，可以得到一棵 n+1 个元素的 AVL 树，插入用时为 $O(logn)$。
1. 一个元素从一棵 n 元素的 AVL 搜索树中删除，可以得到一棵 n-1 个元素的 AVL 树，删除用时为 $O(logn)$。

**描述**：
AVL 树一般用链表描述。为了简化插入和删除操作，为每一个节点增加一个平衡因子 $bf$。节点 x 的平衡因子 $bf(x)$ 定义为：

$x$ 的左子树高度 - $x$ 的右子树高度。

可知，平衡因子可能取值为 -1,0,1。

**操作**：
1. 查找：可二叉树查找一样，用时 O(logn)。
1. 插入：插入和二叉树插入一样，之后如果树有不平衡节点，则进行一次旋转（单旋转和双旋转）操作，使树恢复平衡。
1. 删除：删除和二叉树删除一样，之后如果树有不平衡节点，则进行旋转（单旋转和双旋转）操作，使树恢复平衡。与插入不同，在一次删除操作之后，仅用一次旋转可能无法恢复平衡，所需要的旋转次数为 O(logn)。

注：插入和删除操作的具体过程在此不再详述，可参考这篇博客 <https://segmentfault.com/a/1190000006123188>，或者 google 查找。其中，把矫正 LL 和 RR 型不平衡所做的旋转称为 **单旋转**,把矫正 LR 和 RL 型不平衡所做的旋转称为 **双旋转**。

## 红黑树

**定义**：**红黑树（red-black tree）** 是这样一棵二叉搜索树：树中的每一个节点的颜色或者是黑色或者是红色。其他特征可以用相应的扩充二叉树来说明。

**性质**：
1. 每个节点要么是红的要么是黑的；
1. 根结点是黑的；
1. 外部节点是黑的；
1. 如果一个节点是红的，那么它的两个儿子都是黑的；（在根至外部节点路径上，没有连续两个节点是红色。）
1. 在根结点到外部节点的所有路径上，黑色节点数目都相同。

**定理**：
1. 设从根到外部节点的路径长度(length)是该路径上的指针数量。如果 P 和 Q 是红黑树中的两条从根到外部节点的路径，那么 $length(P){\leq}2length(Q)$。
1. 红黑树的高度 h 和内部节点数量 n 有如下关系：$h{\leq}2log_2(n+1)$。

**操作**：
1. 红黑树的搜索和普通的二叉树搜索一样，用时 O(logn)。
1. 红黑树的插入和删除用时都是 O(logn)，具体过程在此不再详述，具体可 google。

## B 树

### m 叉搜索树

**定义**：**m 叉搜索树（m-way search tree）** 可以是一棵空树。如果非空，它必须满足以下特征：
1. 在相应的扩充搜索树（即用外部节点替换空指针之后所得到的搜索树）中，每个内部节点最多可以有 **m 个孩子** 以及 **1~m-1 个元素**（外部节点不含元素和孩子）；
1. 每一个含有 $p$ 个元素的节点都有 $p+1$ 个孩子；
1. 对任意一个含有 $p$ 个元素的节点，设 $k_1,...,k_p$ 分别是这些元素的关键字。这些元素顺序排列，即 $k_1<k_2<...<k_p$。设 $c_0,c_1,...,c_p$ 是该节点的 $p+1$ 个孩子。在以 $c_0$ 为根的子树中，元素的关键字小于 $k_1$；在以 $c_p$ 为根的子树中，元素的关键字大于 $k_p$；在以 $c_i$ 为根的子树中，元素的关键字大于 $k_i$ 而小于 $k_{i+1}$，其中 $1{\leq}i<p$。

在定义 m 叉搜索树时，把外部节点包括进来是有用的，不过在实际的代码中，不需要专门描述外部节点，只要用空指针来表示就可以了。

**操作**：
1. 搜索：根据节点和的大小关系来依次查找，直到找到该节点，或到达了外部节点。
1. 插入：先按照上步骤查找元素，查到则插入失败，如果查找失败，则将新元素插入到最后一个查找的节点的对应位置，如果该节点以满，则必须生成一个新的节点来容纳新元素。
1. 删除：先查找该元素，查找到就删除，然后根据不同的情况进行调整，具体略。
1. 高度：一棵高度为 $h$ 的 $m$ 叉搜索树（不含外部节点）最少有 $h$ 个元素，最多有 $m^h-1$ 个元素。一棵 $n$ 个元素的 $m$ 叉搜索树的高度在 ${\log}_m(n+1)$ 到 $m$ 之间。

### m 阶 B-树

**定义**：**m-阶 B-树（B-Tree of order m）** 是一棵 $m$ 叉搜索树。如果 B-树非空，那么相应的扩展树满足下列特征：
1. 根结点至少有 2 个孩子；
1. 除根结点以外，所有内部节点至少有 ${\lceil}m/2{\rceil}$ 个孩子；
1. 所有外部节点在同一层。

**定理**：
1. 设 $T$ 是一棵高度为 $h$ 的 $m$ 阶 B-树。令 $d={\lceil}m/2{\rceil}$，n 是 $T$ 的元素个数，则：
    1. $2d^{h-1}-1{\leq}n{\leq}m^h-1$
    1. ${\log}_m(n+1){\leq}h{\leq}{\log}_d(\frac{n+1}{2})+1$

**操作**:
1. 搜索：与 m 叉搜索树的搜索算法相同；
1. 插入：按元素大小插入到相应位置，注意，当在一个饱和节点中插入一个新元素时，需要分裂该节点。（具体方法不再详述）
1. 删除：具体不再详述。注意：当要删除的元素在一个非根结点中且该节点的元素个数最少时，可用其最邻近的左兄弟或右兄弟的元素来替换它；当最邻近的一个兄弟不包含额外元素时，就将两个兄弟与父节点中介于两个兄弟之间的元素合并成一个节点。

注：B 树的具体操作可参考 <http://blog.163.com/zhoumhan_0351/blog/static/39954227200910231032917/>